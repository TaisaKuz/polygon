#include <iostream>
#include <vector>
#include <algorithm>

void bucketSort(float arr[], int n) {
    // Временная сложность: O(n) для выделения памяти 
    // Память: O(n) для хранения ведер
    std::vector<float> b[n];

    for (int i = 0; i < n; i++) {
        // Временная сложность: O(n)
        // Память: Идеальный случай: O(n) в разных ведрах, худший: O(n) в одном.

        int bi = n * arr[i]; 
        b[bi].push_back(arr[i]); 
    }

    for (int i = 0; i < n; i++) {
        // Временная сложность для сортировки одного ведра: O(k * log(k)), где k - размер ведра
        // Временная сложность для всех ведер: O(n * log(n/k)) в среднем случае, если 
        // элементы равномерно распределены. В худшем случае: O(n^2) (все в одном ведре)
        std::sort(b[i].begin(), b[i].end());
    }

    int index = 0; 
    for (int i = 0; i < n; i++)
        for (int j = 0; j < b[i].size(); j++)
            arr[index++] = b[i][j]; 
    // Временная сложность: O(n) - проходим по всем элементам
    // Память: Используется дополнительная память: O(n) для хранения всех элементов.

// Итоговая временная сложность: 
// В среднем: O(n + n * log(n/k)) -> O(n log n) (с равномерно распределёнными данными)
// В худшем: O(n^2) - если все элементы в одном ведре.
// Общая память: O(n) для ведер и O(n) для хранения элементов.
}